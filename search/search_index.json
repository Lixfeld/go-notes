{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Learning Resources","text":"<ul> <li>Tour of Go</li> <li>Effective Go</li> <li>Go by Example</li> <li>Standard library</li> </ul>"},{"location":"basics/constants/","title":"Constants","text":"<p>Declaration: const name type = expression</p> <pre><code>const greeting string = \"Hello World\"\n</code></pre>"},{"location":"basics/constants/#untyped-constants","title":"Untyped Constants","text":"<p>Constants can be untyped which is useful for numbers. The constant will be implicitly converted to the required type.  </p> <p>Examples from package math:  </p> <pre><code>const (\nE        = 2.71828182845904523536028747135266249775724709369995957496696763\nPi       = 3.14159265358979323846264338327950288419716939937510582097494459\nMaxInt8  = 1&lt;&lt;7 - 1 // 127\nMinInt32 = -1 &lt;&lt; 31 // -2147483648\n)\n</code></pre>"},{"location":"basics/constants/#enums","title":"Enums","text":"<p>Go has no enumerations but they can be mimicked by using constants. The value for the keyword <code>iota</code> is incremented by one after each line.  </p> <pre><code>const (\nSummer int = iota // 0\nAutumn            // 1\nWinter            // 2\nSpring            // 3\n)\ntype Direction int\nconst (\nNorth Direction = iota // 0\nEast                   // 1\nSouth                  // 2\nWest                   // 3\n)\n</code></pre>"},{"location":"basics/conversions/","title":"Type conversions","text":"<p>Type conversions <code>T(x)</code> must be explicit and different types need to be compatible.</p> <pre><code>var f float64 = 1.2\n// fraction is discarded\nvar i int = int(f)\nvar s string = \"Hello World\"\nvar r []rune = []rune(s)\nvar b []byte = []byte(s)\n</code></pre>"},{"location":"basics/conversions/#package-strconv","title":"Package strconv","text":"<p>Conversions to and from string representations of basic data types.  </p> <pre><code>// Integer To ASCII\ns := strconv.Itoa(10)\n// Equivalent to ParseInt(s, 10, 0)\ni, err := strconv.Atoi(\"10\")\n</code></pre>"},{"location":"basics/data_types/","title":"Data types","text":"<pre><code>bool\nstring\nint  int8  int16  int32  int64\nuint uint8 uint16 uint32 uint64 uintptr\nbyte // alias for uint8\nrune // alias for int32 (Unicode code point)\nfloat32 float64\ncomplex64 complex128\n</code></pre>"},{"location":"basics/data_types/#zero-values","title":"Zero values","text":"<p>Variables declared without an initial value are set to their zero values:</p> <ul> <li><code>0</code> for numbers</li> <li><code>\"\"</code> for strings (can not be nil)</li> <li><code>false</code> for booleans</li> </ul>"},{"location":"basics/functions/","title":"Functions","text":"<p>The type comes after the variable name.  </p> <pre><code>func add(x int, y int) int {\nreturn x + y\n}\n// same type of parameters\nfunc sub(x, y int) int {\nreturn x - y\n}\n// named return value\nfunc multiply(x, y int) (z int) {\nz = x * y\nreturn\n}\n// multiple return values\nfunc divide(x, y int) (int, int) {\nreturn x / y, x % y\n}\n</code></pre>"},{"location":"basics/functions/#defer","title":"Defer","text":"<p>Defer statements delay the execution until the function that contains the defer keyword has finished. This is similar to a <code>finally</code> block in other languages.  </p> <pre><code>func main() {\ndefer fmt.Print(\"world\")\nfmt.Print(\"hello \")\n// Output: hello world\n}\n// Multiple defer statements\nfunc main() {   defer fmt.Print(\"done\")\nfor i := 1; i &lt;= 3; i++ {\ndefer fmt.Printf(\"%v \", i)\n}\n// Output: 3 2 1 done\n}\n// Cleanup resources\nfunc main() {   file, err := os.Create(\"filename\")\nif err != nil {\npanic(err)\n}\ndefer file.Close()\n}\n</code></pre>"},{"location":"basics/functions/#variadic","title":"Variadic","text":"<p>A variadic function accepts any number of values as a single argument. The type of the last parameter is preceded by an ellipsis (<code>...</code>).  </p> <pre><code>func sum(nums ...int) int {\nvar total = 0\nfor num := range nums {\ntotal += num\n}\nreturn total\n}\n</code></pre>"},{"location":"basics/functions/#default","title":"Default","text":"<p>Unlike many other languages Go does not support optional/default values.  </p>"},{"location":"basics/helloworld/","title":"Hello World","text":"<p>Program execution begins by initializing the <code>main</code> package and then invoking the function <code>main</code>.</p> <pre><code>package main\nimport \"fmt\"\nfunc main() {\nfmt.Println(\"Hello, World!\")\n}\n</code></pre>"},{"location":"basics/if_statements/","title":"If statements","text":"<p>There is no ternary operator in Go.</p> <pre><code>if condition1 {\n// condition1 is true\n} else if condition2 {\n// condition2 is true\n} else {\n// both conditions are false\n}\n</code></pre>"},{"location":"basics/if_statements/#if-with-a-short-statement","title":"If with a short statement","text":"<p>Variables declared at the start are available inside all branches.</p> <pre><code>if assignment; condition {\n// code to execute\n}\n</code></pre>"},{"location":"basics/if_statements/#example","title":"Example","text":"<pre><code>if number, err := strconv.Atoi(\"10\"); err == nil {\nsum += number\n}\n</code></pre>"},{"location":"basics/keywords/","title":"Keywords","text":"<p>Language Specification: https://go.dev/ref/spec#Keywords <pre><code>break        default      func         interface    select\ncase         defer        go           map          struct\nchan         else         goto         package      switch\nconst        fallthrough  if           range        type\ncontinue     for          import       return       var\n</code></pre></p>"},{"location":"basics/loops/","title":"Loops","text":"<p>The <code>for</code> loop is the only loop available in Go.</p> <pre><code>for initialization; condition; post {\n// code to execute\n}\nfor condition {\n// \"while\" loop\n}\nfor {\n// infinite loop\n}\nfor index, value := range elements {\n// foreach loop\n}\nfor i := range integer {\n// \"repeat\" loop\n}\n</code></pre>"},{"location":"basics/loops/#examples","title":"Examples","text":"<pre><code>for i := 0; i &lt; 10; i++ {\n// break or continue\n}\ndictionary := make(map[string]string)\nfor key, value := range dictionary {\n// skip key or value with '_'\n}\n</code></pre>"},{"location":"basics/pointers/","title":"Pointers","text":"<p>A pointer variable stores the memory address of a value. There is no pointer arithmetic in Go.  </p> <pre><code>// Declaration\nvar ptr *type\n// Zero value is nil\nvar p *int\n// Address-of operator (&amp;)\nvar x = 10\np = &amp;x\n// Dereference operator (*)\nfmt.Println(*p) // 10\n*p = 20\nfmt.Println(*p) // 20\nfmt.Println(x)  // 20\n</code></pre>"},{"location":"basics/project_layout/","title":"Project Layout","text":"<p>Small and simple projects can have all their code in one directory:  </p> <pre><code>project-root-directory/\n  go.mod\n  modname.go\n  modname_test.go\n</code></pre> <p>Large server project example: <pre><code>project-root-directory/\n  go.mod\n  internal/\n    auth/\n      ...\n    metrics/\n      ...\n    model/\n      ...\n  cmd/\n    api-server/\n      main.go\n    metrics-analyzer/\n      main.go\n    ...\n  ... the project's other directories with non-Go code\n</code></pre></p> <p>For more information about the layout, see Organizing a Go module and Standard Go Project Layout.  </p>"},{"location":"basics/switch/","title":"Switch statement","text":"<p>In Go a <code>break</code> statement is added implicitly at the end of each case. The <code>fallthrough</code> keyword can be used to also execute the next case.  </p> <pre><code>// Multiple values\nswitch month {\ncase 1, 2, 3:\nfmt.Println(\"Spring\")\ncase 4, 5, 6:\nfmt.Println(\"Summer\")\ncase 7, 8, 9:\nfmt.Println(\"Autumn\")\ncase 10, 11, 12:\nfmt.Println(\"Winter\")\n}\n// No condition\nswitch {\ncase hour &lt; 12:\nfmt.Println(\"AM\")\ncase hour &lt; 24:\nfmt.Println(\"PM\")\ndefault:\nfmt.Println(\"Invalid\")\n}\n</code></pre>"},{"location":"basics/variables/","title":"Variables","text":"<p>The variable's type can be inferred from the assigned value.</p> <p>Declaration: var name type = expression <pre><code>var s = \"\"\nvar s string\nvar s string = \"\"\n</code></pre></p> <p>Short declaration: name := expression Not for package-level variables, only inside a function!</p> <pre><code>s := \"\"\n</code></pre>"},{"location":"basics/visibility/","title":"Visibility","text":"<p>If a name begins with an upper-case letter, it is <code>exported</code> (PascalCase). Any <code>unexported</code> (camelCase) names are not visible or accessible from outside the package.  </p> <p>There are no access modifiers such as <code>public</code> or <code>private</code>.</p>"},{"location":"basics/visibility/#internal-packages","title":"Internal packages","text":"<p>Put code which should not be used outside the program in a directory named <code>internal</code>.  </p> <p>Go 1.4 release notes: https://golang.org/doc/go1.4#internalpackages </p>"},{"location":"packages/builtin/","title":"Package builtin","text":"<p>Package builtin provides documentation for Go's predeclared identifiers. The items documented here are not actually in package builtin but their descriptions here allow godoc to present documentation for the language's special identifiers.</p> <p>Useful Functions: <pre><code>append(slice []Type, elems ...Type) []Type\nclose(c chan&lt;- Type)\ncopy(dst, src []Type) int\nlen(v Type) int\nmake(t Type, size ...IntegerType) Type\n</code></pre></p>"},{"location":"packages/fmt/","title":"Package fmt","text":"<p>Package fmt implements formatted I/O with functions analogous to C's printf and scanf. The format 'verbs' are derived from C's but are simpler.  </p> <p>Useful Functions: <pre><code>Errorf(format string, a ...any) error\nFprint(w io.Writer, a ...any) (n int, err error)\nPrintf(format string, a ...any) (n int, err error)\nSprintf(format string, a ...any) string\n</code></pre></p> <p>Common format verbs: <pre><code>%b      integer (base 2)\n%c      character (Unicode code point)\n%d      integer (base 10)\n%o      integer (base 8)\n%q      quoted string \"abc\" or rune 'c'\n%s      string\n%T      type of any value\n%v      the value in a default format\n%+v     structs: adds field names\n%#v     a Go-syntax representation of the value\n%%      literal percent sign (no operand)\n</code></pre></p> <p>Decimal numbers: <pre><code>%f      precision 6 (default)\n%.f     precision 0\n%.2f    precision 2\n</code></pre></p>"},{"location":"packages/slices/","title":"Package slices","text":"<p>Released in Go 1.21 Package slices defines various functions useful with slices of any type.  </p> <p>Useful Functions: <pre><code>Contains[S ~[]E, E comparable](s S, v E) bool\nIndex[S ~[]E, E comparable](s S, v E) int\nCompare[S ~[]E, E cmp.Ordered](s1, s2 S) int\nEqual[S ~[]E, E comparable](s1, s2 S) bool\nMin[S ~[]E, E cmp.Ordered](x S) E\nMax[S ~[]E, E cmp.Ordered](x S) E\nReverse[S ~[]E, E any](s S)\nSort[S ~[]E, E cmp.Ordered](x S)\nSortFunc[S ~[]E, E any](x S, cmp func(a, b E) int)\n// Go 1.22\nConcat[S ~[]E, E any](slices ...S) S\n</code></pre></p>"},{"location":"packages/sort/","title":"Package sort","text":"<p>Package sort provides primitives for sorting slices and user-defined collections.  </p> <p>Note: As of Go 1.22, some functions simply call the corresponding functions in the slices package.  </p> <p>Useful Functions: <pre><code>Ints(x []int)\nStrings(x []string)\nSlice(x any, less func(i, j int) bool)\n</code></pre></p>"},{"location":"packages/strconv/","title":"Package strconv","text":"<p>Package strconv implements conversions to and from string representations of basic data types.  </p> <p>Useful Functions: <pre><code>Atoi(s string) (int, error)\nItoa(i int) string\nParseInt(s string, base int, bitSize int) (i int64, err error)\nFormatInt(i int64, base int) string\n</code></pre></p>"},{"location":"packages/strings/","title":"Package strings","text":"<p>Package strings implements simple functions to manipulate UTF-8 encoded strings. For information about UTF-8 strings in Go, see https://blog.golang.org/strings.  </p> <p>Useful Functions: <pre><code>Contains(s, substr string) bool\nHasPrefix(s, prefix string) bool\nHasSuffix(s, suffix string) bool\nIndex(s, substr string) int\nJoin(elems []string, sep string) string\nRepeat(s string, count int) string\nReplaceAll(s, old, new string) string\nSplit(s, sep string) []string\nToLower(s string) string\nToUpper(s string) string\nTrimSpace(s string) string\n</code></pre></p> <p>Useful Types: <pre><code>Builder\n- (b *Builder) WriteString(s string) (int, error)\n- (b *Builder) String() string\nReplacer\n- NewReplacer(oldnew ...string) *Replacer\n- (r *Replacer) Replace(s string) string\n</code></pre></p>"},{"location":"packages/sync/","title":"Package sync","text":"<p>Package sync provides basic synchronization primitives such as mutual exclusion locks. Other than the Once and WaitGroup types, most are intended for use by low-level library routines. Higher-level synchronization is better done via channels and communication.  </p> <p>Values containing the types defined in this package should not be copied.  </p> <p>Useful Types: <pre><code>WaitGroup\n- (wg *WaitGroup) Add(delta int)\n- (wg *WaitGroup) Done()\n- (wg *WaitGroup) Wait()\nMutex // Mutual Exclusion\n- (m *Mutex) Lock()\n- (m *Mutex) Unlock()\n</code></pre></p>"},{"location":"packages/unicode/","title":"Package unicode","text":"<p>Package unicode provides data and functions to test some properties of Unicode code points.  </p> <p>Useful Functions: <pre><code>ToLower(r rune) rune\nToUpper(r rune) rune\nIsLetter(r rune) bool\nIsNumber(r rune) bool\nIsDigit(r rune) bool\n</code></pre></p>"},{"location":"types/arrays/","title":"Arrays","text":"<p>The length of an array is fixed and part of its type. </p> <pre><code>// Declaration\nvar array [n]type\n// Length defined\nvar b = [3]int{1, 2, 3}\n// Length inferred\nvar c = [...]int{1, 2, 3, 4}\n</code></pre>"},{"location":"types/interfaces/","title":"Interfaces","text":"<p>An interface contains a collection of method signatures. Interfaces are implemented implicitly. There is no <code>implements</code> keyword.  </p> <pre><code>// Declaration\ntype name interface{}\ntype Shape interface {\nArea() float64\n}\n// Struct for implementation\ntype rectangle struct {\nwidth, height float64\n}\nfunc (r rectangle) Area() float64 {\nreturn r.Width * r.Height\n}\n</code></pre>"},{"location":"types/interfaces/#the-empty-interface","title":"The empty interface","text":"<p>An empty interface (<code>interface{}</code> or <code>any</code> with Go 1.18+) is implemented by all types.  </p>"},{"location":"types/interfaces/#type-assertions","title":"Type assertions","text":"<p>Access the underlying concrete type of an interface with type assertion.  </p> <pre><code>var i interface{} = \"text\"\n// panic if type is wrong\nvar s string = i.(string)\n// check type\ns, ok := i.(string)\n</code></pre>"},{"location":"types/interfaces/#type-switches","title":"Type switches","text":"<p>Instead of the specific type, the keyword <code>type</code> is used.  </p> <pre><code>var i interface{} = 1\nswitch v := i.(type) {\ncase int:\n// type of v = int\ncase string:\n// type of v = string\ndefault:\n// type of v = same type as i\n}\n</code></pre>"},{"location":"types/maps/","title":"Maps","text":"<p>A map stores a collection of key/value pairs. In other languages a map is called a hash table or dictionary.  The key type in a map (<code>map[keyType]valueType</code>) must be a comparable type.  </p> <pre><code>// Create a map\nvar m = make(map[string]string)\n// Insert or update\nm[\"key\"] = \"value\"\n// Get element or zero value\nvar value = m[\"key\"]\n// Contains key\nv, ok := m[\"key\"]\n// Delete key-value pair\ndelete(m, \"key\")\n// Remove all key-value pairs\nclear(m)\n// Map Literal\nvar table = map[int]string{\n1: \"A\",\n2: \"B\",\n3: \"C\",\n}\n</code></pre>"},{"location":"types/maps/#nil-map","title":"Nil map","text":"<p>Writing to a nil map will panic. Initialize a map with the built in <code>make</code> function.  </p>"},{"location":"types/methods/","title":"Methods","text":"<p>Methods are similar to functions but they operate on instances of a specific type (receiver). There is no <code>this</code> or<code>self</code> keyword in Go but it is a convention to use the first letter of the receiver.</p> <pre><code>type rectangle struct {\nwidth, height float64\n}\nfunc (r rectangle) Area() float64 {\nreturn r.Width * r.Height\n}\n</code></pre>"},{"location":"types/methods/#value-and-pointer-receivers","title":"Value and pointer receivers","text":"<p>A value receiver <code>(t T)</code> uses a copy of the original value. To modify the original value a pointer receiver  <code>(t *T)</code> is needed. For consistency, all methods on a type should use the same receiver type, even if not needed.  </p>"},{"location":"types/named_types/","title":"Named Types","text":"<p>Named types can be used to differ between multiple incompatible types with the same underlying type.  </p> <pre><code>// Declaration\ntype name underlyingType\n// Example\ntype Celsius float64\ntype Fahrenheit float64\n</code></pre>"},{"location":"types/slices/","title":"Slices","text":"<p>A slice is like a reference to an array. The length of a slice can change by re-slicing or appending items.  </p> <pre><code>// Create a slice from an array\nvar array = [5]int{0, 1, 2, 3, 4}\n// The \"end\" element is excluded\nvar slice = array[start:end]\n// Slice literal\nvar hello = []byte{'h', 'e', 'l', 'l', 'o'}\n// Make a slice with zero values\nvar name = make([]type, length, capacity)\n</code></pre>"},{"location":"types/slices/#appending-to-a-slice","title":"Appending to a slice","text":"<p>The built-in append function also works on nil slices.</p> <pre><code>var slice []int\nslice = append(slice, 1)\nvar slice2 = []int{2, 3}\n// ... unpacks the second slice\nslice = append(slice, slice2...)\n</code></pre>"},{"location":"types/slices/#empty-slice","title":"Empty slice","text":"<p>Check for an empty slice with <code>len(s) == 0</code> and not <code>s == nil</code> because for example <code>s := []int{}</code> is not nil.</p>"},{"location":"types/structs/","title":"Structs","text":"<p>A struct can group data with different types.  </p> <pre><code>// Declaration\ntype name struct{}\n// Named fields in a struct\ntype Point struct {\nX int\nY int\n}\n// New struct\nvar p1 = Point{1, 2}\nvar p2 = Point{X: 1, Y: 2}\n// Zero values\nvar p3 Point = Point{}\n</code></pre> <p>Fields can be accessed with a struct pointer without explicit dereference. Example: Write <code>p.X</code> instead of <code>(*p).X</code>.  </p>"}]}